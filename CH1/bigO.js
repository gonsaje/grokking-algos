// Imagine a square piece of paper.
// You're tasked with drawing 16 cubes on the paper
// You can either draw each cub one by one
// or you can fold the paper in half to create boxes in half the time


// Big O establishes a worst-case run time

// Common run times:

// O(log n) => log time (ex. Binary Search)
// O(n) => linear time (ex. Simple Search)
// O(n * log n) => A fast sorting algorithm (ex. Quick Sort)
// O(n^2) => A slow sorting algorithm (ex. Selection Sort)
// O(n!) => a really slow algorithm (ex. traveling salesperson)

// Algorithms are not measured by runtime, but number of operations 

// Exercises:

// 1.3
// You have a name, and you want to find the person's phone number in the book
// O(log n)

// 1.4
// You have a phone number and want to find a person's name in the phone book
// (Hint: You'll have to search trhu the whole book!)
// O(n)

// 1.5
// You want to read numbers of every person in the phonebook
// O(n)

// 1.6
// You want to read the numbers of just the A's
// O(n)